/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>
#include <hamsandwich>
#include <fun>
#include <cstrike>
#include <engine>
#include <zombieplague>

/* Credits 
Numb - For his Weapon Balancer */

#define m_pPlayer 41
#define m_iId 43
#define m_iClip 51
#define m_flNextPrimaryAttack   46
#define m_flNextSecondaryAttack 47

#define PLUGIN "X-Radiation Ring"
#define VERSION "1.0.1"
#define AUTHOR "Kia"

/* Integer */

new g_iItemID
new g_iOldClip
new g_iShotgunOwner

/* Floats */

new Float:g_fBackupAngle[3]
new Float:g_fAimFrom[3]
new Float:g_fAimTo[3]

/* Boolean */

new bool:g_bHasXRR[33]

/* Precache */

new const szPModel[] = "models/p_xrr.mdl"
new const szVModel[] = "models/v_xrr.mdl"

/* CVars */

new pC_Mode

public plugin_precache()
{
	precache_model(szPModel)
	precache_model(szVModel)
}

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	/* Registering Item */
	
	g_iItemID = zp_register_extra_item("Arma cu radiatii(o runda)", 45, ZP_TEAM_HUMAN)
	
	/* Hamsandwich */
	
	RegisterHam(Ham_Weapon_PrimaryAttack, "weapon_m3",    "func_HamWeaponM3_Pre",  0)
	RegisterHam(Ham_Weapon_PrimaryAttack, "weapon_m3",    "func_HamWeaponM3", 1)
	
	/* Events */
	
	register_event("CurWeapon", "func_EventCurWeapon", "be", "1=1")
	register_event("DeathMsg", "func_EventDeathMsg", "a")
	
	/* Logevents */
	
	register_logevent("LogEvent_RoundEnd", 2, "1=Round_End")  
	
	/* CVars */
	
	pC_Mode = register_cvar("xrr_mode", "2") // 1 (At Death) - 2 (At Round Begin)
}

public zp_extra_item_selected(id, ItemID)
{
	if(ItemID == g_iItemID )
	{
		g_bHasXRR[id] = true
		give_item(id, "weapon_m3")
		cs_set_user_bpammo(id, CSW_M3, 5000)
	}
}


public func_EventCurWeapon(id)
{
	if(!is_user_alive(id)) 
		return PLUGIN_CONTINUE
	
	new temp[2], weapon = get_user_weapon(id, temp[0], temp[1])
	if(weapon == CSW_M3)
	{
		if(g_bHasXRR[id])
		{
			entity_set_string(id, EV_SZ_viewmodel, szVModel)
			entity_set_string(id, EV_SZ_weaponmodel, szPModel)
		}
	}
	return PLUGIN_CONTINUE
}

public func_EventDeathMsg()
{
	new iVictim = read_data(2)
	if(g_bHasXRR[iVictim] && get_pcvar_num(pC_Mode) == 1)
		g_bHasXRR[iVictim] = false
}

public LogEvent_RoundEnd()
{
	if(get_pcvar_num(pC_Mode) != 2)
		return PLUGIN_HANDLED
	
	new players[32], pnum, tempid
	get_players(players, pnum)
	
	for( new i; i<pnum; i++ ) 
	{
		tempid = players[i]
		if(g_bHasXRR[tempid])
			g_bHasXRR[tempid] = false
	}
	
	return PLUGIN_HANDLED
}

public func_HamWeaponM3(iEnt)
{
	if(g_iOldClip>get_pdata_int(iEnt, m_iClip, 4) && g_iOldClip> 1 && pev(g_iShotgunOwner, pev_button) && IN_ATTACK2 && g_bHasXRR[g_iShotgunOwner])
	{
		static Float:s_fAngleDifference, Float:s_fOldAngle
		set_pev(g_iShotgunOwner, pev_punchangle, g_fBackupAngle)
		s_fOldAngle = g_fBackupAngle[0]
		ExecuteHamB(Ham_Weapon_PrimaryAttack, iEnt)
		pev(g_iShotgunOwner, pev_punchangle, g_fBackupAngle)
		s_fAngleDifference = (g_fBackupAngle[0]-s_fOldAngle)
		if( g_fBackupAngle[0]>-25.0 && g_fBackupAngle[0]<0.0 )
		{
			s_fAngleDifference *= 2.1;
			g_fBackupAngle[0] = (s_fOldAngle+s_fAngleDifference)
			if( g_fBackupAngle[0]<-25.0 )
				g_fBackupAngle[0] = -25.0
			set_pev(g_iShotgunOwner, pev_punchangle, g_fBackupAngle)
		}
	}
}

public func_HamWeaponM3_Pre(iEnt)
{
	if( (g_iOldClip=get_pdata_int(iEnt, m_iClip, 4))>0 )
	{
		if( pev((g_iShotgunOwner=get_pdata_cbase(iEnt, m_pPlayer, 4)), pev_waterlevel)!=3 )
		{
			static Float:s_fViewOfs[3], Float:s_fAngle[3];
			pev(g_iShotgunOwner, pev_origin, g_fAimFrom);
			pev(g_iShotgunOwner, pev_view_ofs, s_fViewOfs);
			pev(g_iShotgunOwner, pev_v_angle, s_fAngle);
			g_fAimFrom[0] += s_fViewOfs[0];
			g_fAimFrom[1] += s_fViewOfs[1];
			g_fAimFrom[2] += s_fViewOfs[2];
			pev(g_iShotgunOwner, pev_punchangle, s_fViewOfs);
			s_fAngle[0] += s_fViewOfs[0];
			s_fAngle[1] += s_fViewOfs[1];
			s_fAngle[2] += s_fViewOfs[2];
			
			s_fAngle[0] *= -1;
			if( get_pdata_int(iEnt, m_iId, 4)==CSW_M3 )
			{
				SphereToCartesian(g_fAimTo, g_fAimFrom, s_fAngle, Float:{0.0, 0.0, 3000.0});
			}
			else
			{
				SphereToCartesian(g_fAimTo, g_fAimFrom, s_fAngle, Float:{0.0, 0.0, 3048.0});
			}
			

			
			pev(g_iShotgunOwner, pev_punchangle, g_fBackupAngle);
		}
	}	
}

bool:SphereToCartesian(Float:fDest[3], Float:fOrigin[3], Float:fView[3], Float:fAngle[3])
{
	fView[1] *= (M_PI/180.0);
	fView[0] *= (M_PI/180.0);
	
	fAngle[0] *= (M_PI/-180.0);
	fAngle[1] *= (M_PI/180.0);
	
	static Float:s_fSin0, Float:s_fCos0, Float:s_fSin1, Float:s_fCos1;
	s_fSin0 = floatsin((fAngle[0]+(M_PI*0.5)), radian);
	
	fDest[0] = fAngle[2]*s_fSin0*floatcos(fAngle[1], radian);
	fDest[1] = fAngle[2]*s_fSin0*floatsin(fAngle[1], radian);
	fDest[2] = fAngle[2]*floatcos((fAngle[0]+(M_PI*0.5)), radian);
	
	
	s_fSin0 = floatsin(fView[0], radian);
	s_fCos0 = floatcos(fView[0], radian);
	s_fSin1 = floatsin(fView[1], radian);
	s_fCos1 = floatcos(fView[1], radian);
	
	static Float:s_fTemp[3];
	s_fTemp[0] = (fDest[0]*s_fCos0*s_fCos1)-(fDest[1]*s_fSin1)+(fDest[2]*s_fSin0*s_fCos1);
	s_fTemp[1] = (fDest[0]*s_fCos0*s_fSin1)+(fDest[1]*s_fCos1)+(fDest[2]*s_fSin1*s_fSin0);
	s_fTemp[2] = (fDest[2]*s_fCos0)-(fDest[0]*s_fSin0);
	
	fDest[0] = (fOrigin[0]+s_fTemp[0]);
	fDest[1] = (fOrigin[1]+s_fTemp[1]);
	fDest[2] = (fOrigin[2]-s_fTemp[2]);
	
	return true;
}
